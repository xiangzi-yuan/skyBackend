# 可选参数复用模式（改进版）

## 问题场景

在开发中经常遇到这样的情况：**同一个查询方法需要在不同场景下返回不同的数据集**。

### 典型案例

`getByCategoryId` 方法需要根据分类ID查询菜品列表：

| 调用方 | 需求 |
|--------|------|
| Admin 端 | 查询所有菜品（包括停售的），用于管理 |
| User 端 | 只查询起售中的菜品，用于展示给顾客 |

## 常见解决方案对比

### ❌ 方案1：创建两个完全独立的实现

```java
// Admin 用 - 独立实现
List<DishDetailVO> getByCategoryId(Long categoryId) {
    return dishMapper.selectAll(categoryId);
}

// User 用 - 独立实现
List<DishDetailVO> getByCategoryIdOnSale(Long categoryId) {
    return dishMapper.selectOnSale(categoryId);
}
```

**缺点**：
- 代码冗余，两套 Mapper 逻辑几乎相同
- 违反 DRY 原则
- 后续维护成本高

### ❌ 方案2：在 Service 层过滤

```java
public List<DishDetailVO> getByCategoryIdForUser(Long categoryId) {
    return getByCategoryId(categoryId).stream()
        .filter(d -> d.getStatus() == 1)
        .toList();
}
```

**缺点**：
- 先查出所有数据再过滤，性能浪费
- 数据量大时可能导致内存问题

### ❌ 方案3（初版错误做法）：Service 层暴露可选参数

```java
// ❌ 把可选参数暴露给 Controller
List<DishDetailVO> getByCategoryId(Long categoryId, Integer status);

// Controller 调用时传 null
dishService.getByCategoryId(categoryId, null);           // Admin
dishService.getByCategoryId(categoryId, StatusConstant.ENABLE);  // User
```

**缺点**：
- **语义污染**：Service 接口暴露了数据库过滤字段的细节
- **越权风险**：业务规则"用户只能看起售"被散落在调用处，误传 null 就绕过规则
- **可读性差**：调用点 `null` 的含义需要脑补

### ✅ 方案4（推荐）：语义接口 + 内部复用

**核心思路**：
- Service 对外暴露**语义清晰的业务方法**
- 内部通过 private 方法复用 Mapper 的可选参数逻辑

## 正确实现方式

### 1. Mapper 接口（可选参数在这一层）

```java
/**
 * 根据分类ID查询菜品列表（内部使用）
 * @param categoryId 分类ID
 * @param status 状态（可选，null 表示不过滤）
 */
List<DishDetailRM> getByCategoryId(@Param("categoryId") Long categoryId, 
                                   @Param("status") Integer status);
```

### 2. Mapper XML（动态 SQL + 明确字段列表）

```xml
<!-- 根据分类ID查询菜品列表，支持可选的状态过滤（内部方法使用） -->
<select id="getByCategoryId" resultType="com.sky.readmodel.dish.DishDetailRM">
    select d.id,
           d.name,
           d.category_id,
           c.name as category_name,
           d.price,
           d.image,
           d.description,
           d.status
    from dish d
    left join category c on d.category_id = c.id
    <where>
        d.is_deleted = 0
        and d.category_id = #{categoryId}
        <if test="status != null">
            and d.status = #{status}
        </if>
    </where>
</select>
```

> ⚠️ **注意**：禁止使用 `select *`，必须明确列出字段，保持与 RM 一致

### 3. Service 接口（语义清晰的业务方法）

```java
/**
 * 根据分类ID查询起售中的菜品列表（User 端专用）
 * <p>业务规则：用户只能看到起售状态的菜品
 */
List<DishDetailVO> listOnSaleByCategoryId(Long categoryId);

/**
 * 根据分类ID查询所有菜品列表（Admin 端专用）
 * <p>包含所有状态的菜品，用于管理
 */
List<DishDetailVO> listAllByCategoryId(Long categoryId);
```

### 4. Service 实现（内部复用）

```java
@Override
public List<DishDetailVO> listOnSaleByCategoryId(Long categoryId) {
    return listByCategoryIdInternal(categoryId, StatusConstant.ENABLE);
}

@Override
public List<DishDetailVO> listAllByCategoryId(Long categoryId) {
    return listByCategoryIdInternal(categoryId, null);
}

/**
 * 内部复用方法：根据分类ID查询菜品列表
 * @param categoryId 分类ID
 * @param status 状态（null 表示不过滤）
 */
private List<DishDetailVO> listByCategoryIdInternal(Long categoryId, Integer status) {
    List<DishDetailRM> dishDetailRMList = dishMapper.getByCategoryId(categoryId, status);
    return dishDetailRMList.stream()
            .map(dishReadConvert::toDetailVO)
            .toList();
}
```

### 5. Controller 调用（无 null，语义明确）

```java
// Admin Controller
dishService.listAllByCategoryId(categoryId);

// User Controller
dishService.listOnSaleByCategoryId(categoryId);
```

## 对比：初版 vs 改进版

| 维度 | 初版（❌） | 改进版（✅） |
|------|-----------|-------------|
| Service 接口 | 暴露 `status` 可选参数 | 暴露语义明确的业务方法 |
| Controller 调用 | 传 `null` 或常量 | 直接调用语义方法 |
| 业务规则保障 | 依赖调用方"自觉" | Service 内部强制保证 |
| 可读性 | 需要理解 `null` 含义 | 方法名自解释 |
| 越权风险 | 误传参数可绕过规则 | 无法绕过 |

## 设计原则

### 1. 可选参数只在 Mapper 层

Mapper 是数据访问层，动态 SQL 很适合处理可选条件。

### 2. Service 对外提供语义稳定的业务方法

不要把"数据库字段过滤"暴露给上层，应该转化为业务语义。

### 3. `null` 语义只在内部使用

对外接口不应该让调用方传 `null`，含义不清晰且容易出错。

### 4. 禁止 `select *`

明确列出查询字段：
- 字段变更不会导致返回对象异常
- 清楚知道依赖哪些列
- 避免不必要的 IO 浪费

## 适用场景

1. **状态过滤**：启用/禁用、上架/下架、审核中/已通过
2. **权限区分**：管理员查看全部，普通用户查看部分
3. **时间范围**：可选的开始/结束时间
4. **分页参数**：可选的分页条件

## 何时使用 DTO 封装

当可选参数超过 2-3 个时，应该使用 DTO 封装：

```java
@Data
public class DishQueryDTO {
    private Long categoryId;      // 必填
    private Integer status;       // 可选
    private String keyword;       // 可选
    private BigDecimal minPrice;  // 可选
}
```

## 相关文件

- [DishMapper.java](../sky-server/src/main/java/com/sky/mapper/DishMapper.java)
- [DishMapper.xml](../sky-server/src/main/resources/mapper/DishMapper.xml)
- [DishService.java](../sky-server/src/main/java/com/sky/service/DishService.java)
- [DishServiceImpl.java](../sky-server/src/main/java/com/sky/service/impl/DishServiceImpl.java)
- [Admin DishController.java](../sky-server/src/main/java/com/sky/controller/admin/DishController.java)
- [User DishController.java](../sky-server/src/main/java/com/sky/controller/user/DishController.java)
